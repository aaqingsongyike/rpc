package com.example.rpc.util.hystrix;import com.example.rpc.util.proxy.RPCClient;import com.netflix.hystrix.*;import org.aopalliance.intercept.MethodInvocation;public class HystrixUtils extends HystrixCommand<String> {    private String tag;    private RPCClient rpcClient;    private MethodInvocation invocation;    public HystrixUtils(String tag) {        super(Setter            .withGroupKey(HystrixCommandGroupKey.Factory.asKey("SystemTestApp"))            .andCommandKey(HystrixCommandKey.Factory.asKey("HystrixUtils1"))            .andCommandPropertiesDefaults(                    HystrixCommandProperties.Setter()                            .withCircuitBreakerEnabled(true)  // 确定断路器是否用于跟踪运行状况和短路请求（如果跳闸）。                            .withExecutionTimeoutEnabled(true)                            // we default to a 600ms timeout for primary                            .withExecutionTimeoutInMilliseconds(5000)                            .withCircuitBreakerRequestVolumeThreshold(10)//至少有10个请求，熔断器才进行错误率的计算                            .withCircuitBreakerSleepWindowInMilliseconds(5000)//熔断器中断请求5秒后会进入半打开状态,放部分流量过去重试                            .withCircuitBreakerErrorThresholdPercentage(50)//错误率达到50开启熔断保护                            .withFallbackEnabled(true)                            .withExecutionIsolationThreadInterruptOnFutureCancel(false)  // 当发生取消时，执行是否应该中断。默认值为false, THREAD模式有效                            .withExecutionIsolationThreadInterruptOnTimeout(true)  // 在发生超时时是否应中断HystrixCommand.run（）执行。默认值：true, THREAD模式有效                            // 隔离策略，有THREAD和SEMAPHORE                            //THREAD - 它在单独的线程上执行，并发请求受线程池中的线程数量的限制                            //SEMAPHORE - 它在调用线程上执行，并发请求受到信号量计数的限制                            .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.THREAD)                            // 设置在使用时允许到HystrixCommand.run（）方法的最大请求数。SEMAPHORE模式有效, 默认值：10                            // .withFallbackIsolationSemaphoreMaxConcurrentRequests(10)            )                .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey("HystrixThreadPoolName"))  // 线程池的名字                .andThreadPoolPropertiesDefaults(HystrixThreadPoolProperties.Setter()                        .withCoreSize(10)                        .withMaxQueueSize(2)    // 队列中的最大长度                        // 此属性设置队列大小拒绝阈值 - 即使未达到maxQueueSize也将发生拒绝的人为最大队列大小。                        // 此属性存在，因为BlockingQueue的maxQueueSize不能动态更改，我们希望允许您动态更改影响拒绝的队列大小。                        .withQueueSizeRejectionThreshold(2)                )   // 线程池的属性        );        this.tag = tag;    }    @Override    protected String run() throws Exception {        System.out.println("请求的路径url=" + tag);        try {            Object rpcClient = this.rpcClient.getRPCClient(invocation);            return (String) rpcClient;        } catch (Throwable throwable) {            throwable.printStackTrace();        }        return "tag_id:" + tag;    }    @Override    protected String getFallback() {        System.out.println("降级处理");        return "降级处理";    }    @Override    protected String getFallbackMethodName() {        System.out.println("fallback method name");        return super.getFallbackMethodName();    }    public RPCClient getRpcClient() {        return rpcClient;    }    public void setRpcClient(RPCClient rpcClient) {        this.rpcClient = rpcClient;    }    public MethodInvocation getInvocation() {        return invocation;    }    public void setInvocation(MethodInvocation invocation) {        this.invocation = invocation;    }}